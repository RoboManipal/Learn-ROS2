{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"ROS2 Tutorials <p>      The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications.     From drivers and state-of-the-art algorithms to powerful developer tools, ROS has the open source tools you need for your next robotics project.     The official documentation for ROS2 and its distributions can be found here. </p> <p>Note</p> <p>This tutorial assumes that you have dual booted your system with Ubuntu 22.04 or have a WSL2 installation of Ubuntu 22.04 on your Windows machine.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install ROS2, you need the <code>Ubuntu 22.04</code> Jammy Jellyfish release. You can download the ISO file from here.</p>"},{"location":"#installing-ros2","title":"Installing ROS2","text":"<p>Once you have installed Ubuntu 22.04, open a terminal instance and run the following commands:</p> Bash<pre><code>sudo apt install software-properties-common  # install add-apt-repository\nsudo add-apt-repository universe  # add universe repository\n</code></pre> <p>This will add the universe repository to your system. Now, run the following commands to install <code>curl</code> and add the ROS2 keyring to your system.</p> Bash<pre><code>sudo apt update &amp;&amp; sudo apt install curl -y  # update and install curl\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg  # add ROS2 keyring\n</code></pre> <p>Note</p> <p>A keyring is a collection of cryptographic keys that are stored in a file on your system. The keyring is used to verify the authenticity of the packages that you install on your system. Here, we are adding the ROS2 keyring to our system.</p> <p></p> <p>Now, add the ROS2 repository to your system and install ROS2.</p> Bash<pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null  # add ROS2 repository\nsudo apt update &amp;&amp; sudo apt upgrade  # update the package list and upgrade the packages\n</code></pre> <p>Note</p> <p>The <code>tee</code> command is used to write the output of a command to a file. Here, we are writing the ROS2 repository to the <code>/etc/apt/sources.list.d/ros2.list</code> file. The <code>&gt; /dev/null</code> part is used to suppress the output of the command.</p> <p></p> <p>Now, install ROS2.</p> Bash<pre><code>sudo apt install ros-humble-desktop  # install ROS2\n</code></pre> <p></p> <p>With this, you have successfully installed ROS2 on your system. Now, you need to source the ROS2 setup file to your <code>.bashrc</code> file. This will allow you to use ROS2 commands in your terminal.</p> Bash<pre><code>echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc  # source the ROS2 setup file, run this only once\nsource ~/.bashrc  # source the .bashrc file, reloads the current terminal instance\ntail ~/.bashrc  # check if the setup file has been sourced\n</code></pre> <p>Note</p> <p>The <code>&gt;&gt;</code> operator is used to append the output of a command to a file. Here, we are appending the <code>source /opt/ros/humble/setup.bash</code> command to the <code>.bashrc</code> file. <code>.bashrc</code> is a hidden file in your home directory that is executed every time you open a terminal instance.</p> <p></p> <p>Now, run the following command to check if ROS2 has been installed successfully.</p> Bash<pre><code>ros2 doctor  # check if ROS2 has been installed successfully\n</code></pre> <p></p>"},{"location":"#running-examples","title":"Running examples","text":"<p>Now, let's run some examples to check if ROS2 is working properly. Run the following commands to run the <code>talker</code> and <code>listener</code> examples.</p> Bash<pre><code>ros2 run demo_nodes_cpp talker  # run the talker example\n</code></pre> <p>Now, open a new terminal instance and run the following command.</p> Bash<pre><code>ros2 run demo_nodes_py listener  # run the listener example\n</code></pre> <p></p>"},{"location":"#submitting-tasks","title":"Submitting Tasks","text":"<p>To submit a task or exercise, you need to fork this repository and make changes in your forked repository.</p>"},{"location":"#forking-the-repository","title":"Forking the Repository","text":"<p>Head over to this repository and click on the fork button on the top right corner of the page.</p> <p></p> <p>This will create a copy of the repository in your GitHub account. Now, clone the repository to your system.</p> Bash<pre><code>git clone &lt;your-forked-repo-url&gt;  # clone the repository\ncd Learn-ROS2  # change directory to the repository\n</code></pre>"},{"location":"#making-changes","title":"Making Changes","text":"<p>Open the folder in your favourite editor and make changes to the files. Once you are done, run the following commands to commit your changes.</p> Bash<pre><code>git add .  # add all the files to the staging area\ngit commit -m \"Add &lt;task-name&gt;\"  # commit your changes\ngit push origin master  # push your changes to your forked repository\n</code></pre> <p></p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>ROS2 Documentation</li> <li>ROS2 Tutorials</li> <li>ROS2 Index</li> <li>ROS2 GitHub</li> </ul>"},{"location":"colcon/","title":"Colcon for beginners","text":""},{"location":"colcon/#what-is-colcon","title":"What is colcon?","text":"<p>Colcon is a command line tool to improve the workflow of building, testing and using multiple software packages. It automates the process, handles the ordering and sets up the environment to use the packages. It is a replacement for the old <code>catkin_make</code> and <code>catkin_tools</code> tools.</p>"},{"location":"colcon/#how-to-install-colcon","title":"How to install colcon?","text":"<p>Colcon is split into multiple packages. The core package is <code>colcon-core</code> and it is required to use colcon. The other packages are optional and provide additional functionality.</p> Bash<pre><code>sudo apt install python3-colcon-common-extensions\n</code></pre> <p>The <code>colcon-common-extensions</code> package provides the most common extensions for colcon. It is recommended to install it.</p> <p>Autocompletes for colcon</p> <p>To use the autocompletes for colcon run the following command:</p> Bash<pre><code>echo \"source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>You can use the autocompletes by pressing the Tab key after typing <code>colcon</code> in the terminal.</p>"},{"location":"colcon/#ros-2-workspace-and-packages","title":"ROS 2 Workspace and Packages","text":"<p>Colcon uses a workspace to build and test packages. A workspace is a directory that contains multiple packages. The workspace is created with the <code>colcon build</code> command.</p> <p>A ROS 2 workspace looks like this:</p> Text Only<pre><code>workspace\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 package_1\n    \u251c\u2500\u2500 package_2\n    \u2514\u2500\u2500 package_3\n</code></pre> <ul> <li><code>build</code>: This directory contains the build files of the packages.</li> <li><code>install</code>: This directory contains the installed packages.</li> <li><code>log</code>: This directory contains the log files of the build and test process.</li> <li><code>src</code>: This directory contains the source code of the packages. This is the directory where you put your packages and code.</li> </ul>"},{"location":"colcon/#create-a-ros-2-workspace","title":"Create a ROS 2 Workspace","text":"<p>To create a workspace, use the following commands:</p> Bash<pre><code>mkdir -p ~/ros2_ws/src  # we need to create the src directory first since it is not created automatically\ncd ~/ros2_ws\ncolcon build\n</code></pre> <p></p>"},{"location":"colcon/#create-a-ros-2-package","title":"Create a ROS 2 Package","text":"<p>A package is an organized collection of code in a ros2 workspace. A package can be installed, built, tested and used independently from other packages. A package can contain multiple nodes, libraries, executables, scripts, etc.</p> <p>To create a package, use the following command:</p> C++Python Bash<pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_cmake --node-name my_node my_package --license MIT --description \"My package\"\n</code></pre> <p>Structure of a C++ package:</p> Text Only<pre><code>my_package\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502   \u2514\u2500\u2500 my_package\n\u2502       \u2514\u2500\u2500 my_node.hpp\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 my_node.cpp\n\u2514\u2500\u2500 test\n    \u2514\u2500\u2500 test_my_node.cpp\n</code></pre> <ul> <li><code>CMakeLists.txt</code>: This file contains the build instructions for the package.</li> <li><code>include</code>: This directory contains the header files of the package.</li> <li><code>package.xml</code>: This file contains the metadata of the package.</li> <li><code>src</code>: This directory contains the source files of the package.</li> </ul> Bash<pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python --node-name my_node my_package --license MIT --description \"My package\"\n</code></pre> <p>Structure of a Python package:</p> Text Only<pre><code>my_package\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 my_package\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 my_node.py\n    \u2514\u2500\u2500 test\n        \u2514\u2500\u2500 test_my_node.py\n</code></pre> <ul> <li><code>package.xml</code>: This file contains the metadata of the package.</li> <li><code>setup.cfg</code>: This file contains the build instructions for the package.</li> <li><code>setup.py</code>: This file contains the build instructions for the package.</li> <li><code>my_package</code>: This directory contains the source files of the package.</li> </ul> <p></p> <p>Multiple packages</p> <p>You can create multiple packages in the <code>src</code> directory. The <code>colcon build</code> command will build all packages in the <code>src</code> directory.</p>"},{"location":"colcon/#build-a-ros-2-package","title":"Build a ROS 2 Package","text":"<p>To build a package, use the following command:</p> Bash<pre><code>cd ~/ros2_ws  # or cd .. if you are in the src directory\ncolcon build\n</code></pre> <p>Building a package will create the build files of the package in the <code>build</code> directory and the installed files of the package in the <code>install</code> directory.</p> <p></p> <p>Build a single package</p> <p>The <code>colcon build</code> command will build all packages in the workspace. To build a single package, use the <code>colcon build --packages-select my_package</code> command. Alternatively, you can use the <code>colcon build --packages-up-to my_package</code> command to build the specified package and all packages that it depends on.</p>"},{"location":"colcon/#run-a-ros-2-package","title":"Run a ROS 2 Package","text":"<p>To run a package, use the following command:</p> Bash<pre><code>cd ~/ros2_ws\nsource install/setup.bash  # source the setup file of the workspace\nros2 run my_package my_node\n</code></pre> <p>Sourcing the setup file of the workspace is required to set up the environment to use the packages in the workspace. It adds the executables in the <code>install</code> directory to your environment.</p> C++Python <p>The <code>ros2 run my_package my_node</code> command will run the executable file of the node. The executable file is created in the <code>install</code> directory.</p> <p></p> <p>The <code>ros2 run my_package my_node</code> command will run the Python script of the node. The Python script is created in the <code>install</code> directory.</p> <p></p>"},{"location":"colcon/#test-a-ros-2-package","title":"Test a ROS 2 Package","text":"<p>To test a package, use the following command:</p> Bash<pre><code>cd ~/ros2_ws\ncolcon test\n</code></pre> <p>The <code>colcon test</code> command will build and test all packages in the workspace. Testing a package is optional. It is not required to test a package to use it.</p> <p></p> <p>Test a single package</p> <p>The <code>colcon test</code> command will test all packages in the workspace. To test a single package, use the <code>colcon test --packages-select my_package</code> command. Alternatively, you can use the <code>colcon test --packages-up-to my_package</code> command to test the specified package and all packages that it depends on.</p>"},{"location":"pub_sub/","title":"Creating a Publisher and Subscriber","text":"<p>A publisher and subscriber consists of two nodes that communicate with each other over a topic. The publisher sends messages to the topic, and the subscriber receives messages from the topic. The publisher and subscriber can be written in any language supported by ROS 2.</p>"},{"location":"pub_sub/#prerequisites","title":"Prerequisites","text":"<ul> <li>Creating and Managing Workspaces in ROS 2</li> </ul> <p>A basic understanding of <code>python</code> or <code>C++</code> is recommended.</p>"},{"location":"pub_sub/#what-is-a-node","title":"What is a Node?","text":"<p>In ROS 2, a node is a process that performs computation. Each node is a single modular unit designed to perform a specific task. Nodes communicate with each other over topics, services, actions, and parameters. You can think of a node as a controller responsible for a specific task. For example, a node can be responsible for controlling a robot's wheels, or a node can be responsible for reading sensor data.</p> <p></p> <p>List available Nodes</p> <p>To list all available nodes, run the following command:</p> Bash<pre><code>ros2 node list\n</code></pre> <p>To get information about a specific node, run the following command:</p> Bash<pre><code>ros2 node info /node_name_here\n</code></pre> <p></p>"},{"location":"pub_sub/#what-is-a-topic","title":"What is a Topic?","text":"<p>A topic is a channel over which nodes communicate. A topic is a named bus over which nodes exchange messages. A node can publish messages to a topic, or a node can subscribe to a topic to receive messages. It is a crucial element that allows us to break down a complex system into smaller, more manageable parts.</p> <p>A topic consists of a name, a type, and a message.</p> <ul> <li>The name is a string that identifies the topic.</li> <li>The type is the type of message that the topic will carry.</li> <li>The message is the actual data that is sent over the topic.</li> </ul> <p>Nodes can publish messages to any number of topics and simultaneously subscribe to any number of topics. It can be one-to-one, one-to-many, many-to-one, or many-to-many communication.</p> <p></p> <p>List available Topics</p> <p>To list all available topics, run the following command:</p> Bash<pre><code>ros2 topic list\n</code></pre> <p>To get information about a specific topic, run the following command:</p> Bash<pre><code>ros2 topic info /topic_name_here\n</code></pre> <p>To get the message being transmitted over a specific topic, run the following command:</p> Bash<pre><code>ros2 topic echo /topic_name_here\n</code></pre> <p></p> <p>Each topic has a message type or structure associated with it. To get the message topics with their message types, run the following command:</p> Bash<pre><code>ros2 topic list -t\nros2 interface show /topic_name_here\n</code></pre> <p></p>"},{"location":"pub_sub/#what-is-a-message","title":"What is a Message?","text":"<p>A message is a data structure that is sent over a topic. It is a simple data structure that consists of primitive data types such as integers, floats, strings, and arrays. A message can also contain other messages. A message is defined in the <code>msg</code> directory of the package. For example, the <code>std_msgs</code> package contains the <code>String</code> message type. The <code>String</code> message type is defined in the <code>msg</code> directory of the <code>std_msgs</code> package. To view the <code>String</code> message type, run the following command:</p> Bash<pre><code>$ ros2 interface show std_msgs/msg/String\n\n# This was originally provided as an example message.\n# It is deprecated as of Foxy\n# It is recommended to create your own semantically meaningful message.\n# However if you would like to continue using this please use the equivalent in example_msgs.\n\nstring data\n</code></pre> <p>You can note all valid data types supported by ROS 2 here.</p> <p>To create custom messages, you would use the above data types to create your own message. We will cover this in a later tutorial.</p>"},{"location":"pub_sub/#creating-a-publisher-and-subscriber_1","title":"Creating a Publisher and Subscriber","text":"<p>Let's create a publisher and subscriber in <code>python</code> and <code>C++</code>. We will create a publisher that publishes a message to a topic, and a subscriber that subscribes to the topic and prints the message to the terminal.</p> <p>Create a new package called <code>pub_sub</code>:</p> PythonC++ Bash<pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python py_pubsub\n</code></pre> Bash<pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_cmake cpp_pubsub\n</code></pre>"},{"location":"pub_sub/#creating-a-publisher","title":"Creating a Publisher","text":"<p>Publisher nodes publish messages to a topic. Let's create a publisher node that publishes a message to a topic called <code>topic</code>. Create a new file called <code>publisher.py</code> or <code>publisher.cpp</code> in the <code>py_pubsub</code> or <code>cpp_pubsub</code> package respectively.</p> PythonC++ Bash<pre><code>cd ~/ros2_ws/src/py_pubsub/py_pubsub\ntouch publisher.py\n</code></pre> Bash<pre><code>cd ~/ros2_ws/src/cpp_pubsub/src\ntouch publisher.cpp\n</code></pre> <p>This is where we will write our publisher code. Open the file in your favorite editor and add the following imports:</p> PythonC++ Python<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\n\nclass Publisher(Node):\n    def __init__(self):\n        ...\n\n    def timer_callback(self):\n        ...\n\n\ndef main(args=None):\n    ...\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> C++<pre><code>#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n\nusing namespace std::chrono_literals;\n\n\nclass Publisher : public rclcpp::Node\n{\npublic:\n    Publisher() : Node(\"publisher\")\n    {\n        ...\n    }\n\nprivate:\n    void timer_callback()\n    {\n        ...\n    }\n\n    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;\n    rclcpp::TimerBase::SharedPtr timer_;\n    size_t count_;\n};\n\n\nint main(int argc, char **argv)\n{\n    ...\n}\n</code></pre> <p>Now try to create a publisher node by inheriting from the <code>Node</code> class. Feel free to come back and check the solution if you get stuck.</p> Source Code PythonC++ Python<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Publisher(Node):\n    def __init__(self):\n        super().__init__(\"publisher\")\n        self.publisher_ = self.create_publisher(String, \"topic\", 10)\n        self.timer_ = self.create_timer(0.5, self.timer_callback)\n        self.count_ = 0\n        self.get_logger().info(\"Publisher has been started\")\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f\"Hello World number {self.count_}\"\n        self.publisher_.publish(msg)\n        self.count_ += 1\n        self.get_logger().info(f\"Message has been published {msg.data}\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    publisher = Publisher()\n    rclpy.spin(publisher)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Here is the breakdown of the code:</p> Python<pre><code>class Publisher(Node):\n    def __init__(self):\n        super().__init__(\"publisher\")\n        self.publisher_ = self.create_publisher(String, \"topic\", 10)\n        self.timer_ = self.create_timer(0.5, self.timer_callback)\n        self.count_ = 0\n        self.get_logger().info(\"Publisher has been started\")\n</code></pre> <ul> <li><code>class Publisher(Node)</code>: This line creates a class called <code>Publisher</code> that inherits from the <code>Node</code> class.</li> <li><code>super().__init__(\"publisher\")</code>: This line calls the constructor of the <code>Node</code> class and passes the name of the node as an argument.</li> <li><code>self.publisher_ = self.create_publisher(String, \"topic\", 10)</code>: This line creates a publisher that publishes messages of type <code>String</code> to the topic called <code>topic</code>. The queue size is set to 10, this means that if the messages are published faster than they are being processed, the queue will store up to 10 messages before it starts to discard old ones.</li> <li><code>self.timer_ = self.create_timer(0.5, self.timer_callback)</code>: This line creates a timer that calls the <code>timer_callback</code> function every 0.5 seconds.</li> </ul> Python<pre><code>def timer_callback(self):\n    msg = String()\n    msg.data = f\"Hello World number {self.count_}\"\n    self.publisher_.publish(msg)\n    self.count_ += 1\n    self.get_logger().info(f\"Message has been published {msg.data}\")\n</code></pre> <ul> <li><code>msg = String()</code>: This line creates a new message of type <code>String</code>.</li> <li><code>msg.data = \"Hello World!\"</code>: This line sets the message data to \"Hello World!\".</li> <li><code>self.publisher_.publish(msg)</code>: This line publishes the message to the topic.</li> </ul> Python<pre><code>def main(args=None):\n    rclpy.init(args=args)\n    publisher = Publisher()\n    rclpy.spin(publisher)\n    rclpy.shutdown()\n</code></pre> <ul> <li><code>rclpy.init(args=args)</code>: This line initializes the ROS 2 client library.</li> <li><code>publisher = Publisher()</code>: This line creates an instance of the <code>Publisher</code> class.</li> <li><code>rclpy.spin(publisher)</code>: This line starts the node. It will keep the node running until it is shutdown.</li> <li><code>rclpy.shutdown()</code>: This line shuts down the ROS 2 client library.</li> </ul> C++<pre><code>#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass Publisher : public rclcpp::Node\n{\npublic:\n    Publisher() : Node(\"publisher\")\n    {\n        publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(\"topic\", 10);\n        timer_ = this-&gt;create_wall_timer(500ms, std::bind(&amp;Publisher::timer_callback, this));\n        count_ = 0;\n        RCLCPP_INFO(this-&gt;get_logger(), \"Publisher has been started\");\n    }\n\nprivate:\n    void timer_callback()\n    {\n        auto msg = std_msgs::msg::String();\n        msg.data = \"Hello World number \" + std::to_string(count_++);\n        publisher_-&gt;publish(msg);\n        RCLCPP_INFO(this-&gt;get_logger(), (\"Message has been published\" + msg.data).c_str());\n    }\n\n    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;\n    rclcpp::TimerBase::SharedPtr timer_;\n    size_t count_;\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto publisher = std::make_shared&lt;Publisher&gt;();\n    rclcpp::spin(publisher);\n    rclcpp::shutdown();\n    return 0;\n}\n</code></pre> <p>Here is the breakdown of the code:</p> C++<pre><code>class Publisher : public rclcpp::Node\n{\npublic:\n    Publisher() : Node(\"publisher\")\n    {\n        publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(\"topic\", 10);\n        timer_ = this-&gt;create_wall_timer(500ms, std::bind(&amp;Publisher::timer_callback, this));\n        count_ = 0;\n        RCLCPP_INFO(this-&gt;get_logger(), \"Publisher has been started\");\n    }\n</code></pre> <ul> <li><code>class Publisher : public rclcpp::Node</code>: This line creates a class called <code>Publisher</code> that inherits from the <code>Node</code> class.</li> <li><code>Publisher() : Node(\"publisher\")</code>: This line calls the constructor of the <code>Node</code> class and passes the name of the node as an argument.</li> <li><code>publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(\"topic\", 10)</code>: This line creates a publisher that publishes messages of type <code>String</code> to the topic called <code>topic</code>. The queue size is set to 10, this means that if the messages are published faster than they are being processed, the queue will store up to 10 messages before it starts to discard old ones.</li> </ul> C++<pre><code>void timer_callback()\n{\n    auto msg = std_msgs::msg::String();\n    msg.data = \"Hello World number \" + std::to_string(count_++);\n    publisher_-&gt;publish(msg);\n    RCLCPP_INFO(this-&gt;get_logger(), (\"Message has been published\" + msg.data).c_str());\n}\n</code></pre> <ul> <li><code>auto msg = std_msgs::msg::String()</code>: This line creates a new message of type <code>String</code>.</li> <li><code>msg.data = \"Hello World!\"</code>: This line sets the message data to \"Hello World!\".</li> <li><code>publisher_-&gt;publish(msg)</code>: This line publishes the message to the topic.</li> </ul> C++<pre><code>int main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto publisher = std::make_shared&lt;Publisher&gt;();\n    rclcpp::spin(publisher);\n    rclcpp::shutdown();\n    return 0;\n}\n</code></pre> <ul> <li><code>rclcpp::init(argc, argv)</code>: This line initializes the ROS 2 client library.</li> <li><code>auto publisher = std::make_shared&lt;Publisher&gt;()</code>: This line creates an instance of the <code>Publisher</code> class.</li> <li><code>rclcpp::spin(publisher)</code>: This line starts the node. It will keep the node running until it is shutdown.</li> <li><code>rclcpp::shutdown()</code>: This line shuts down the ROS 2 client library.</li> </ul>"},{"location":"pub_sub/#adding-dependencies-and-installing-the-package","title":"Adding Dependencies and Installing the Package","text":"<p>Now we need to add the dependencies to the <code>package.xml</code> file. Open the <code>package.xml</code> file and add the following dependencies:</p> PythonC++ XML<pre><code>&lt;build_depend&gt;rclpy&lt;/build_depend&gt;\n&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n</code></pre> <p><code>rclpy</code> is the ROS 2 client library for <code>python</code>. <code>std_msgs</code> is the package that contains the <code>String</code> message type.</p> XML<pre><code>&lt;build_depend&gt;rclcpp&lt;/build_depend&gt;\n&lt;exec_depend&gt;rclcpp&lt;/exec_depend&gt;\n&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n</code></pre> <p><code>rclcpp</code> is the ROS 2 client library for <code>C++</code>. <code>std_msgs</code> is the package that contains the <code>String</code> message type.</p> <p>Now we need to make this script executable.</p> PythonC++ <p>In python to allow the script to be executable, we need to edit <code>setup.py</code> file and add the following line:</p> Python<pre><code>entry_points={\n    \"console_scripts\": [\n        \"publisher = py_pubsub.publisher:main\"\n    ],\n},\n</code></pre> <p>This will create a script called <code>publisher</code> that will run the <code>main</code> function in the <code>publisher.py</code> file.</p> <p>In C++ to allow the script to be executable, we need to edit <code>CMakeLists.txt</code> file and add the following lines:</p> CMake<pre><code>find_package(rclcpp REQUIRED)  # To use the rclcpp library\nfind_package(std_msgs REQUIRED)  # To use the String message type\n\nadd_executable(publisher src/publisher.cpp)\nament_target_dependencies(publisher rclcpp std_msgs)\ninstall(TARGETS publisher DESTINATION lib/${PROJECT_NAME})\n</code></pre> <p>This will create an executable called <code>publisher</code> that will run the <code>main</code> function in the <code>publisher.cpp</code> file.</p> <p>Now we need to build and install the package, to verify that everything is working as expected. Run the following commands:</p> Bash<pre><code>cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n</code></pre> <p>Now run the following command to run the publisher:</p> PythonC++ Bash<pre><code>ros2 run py_pubsub publisher\n</code></pre> Bash<pre><code>ros2 run cpp_pubsub publisher\n</code></pre> <p></p>"},{"location":"pub_sub/#creating-a-subscriber","title":"Creating a Subscriber","text":"<p>Subscriber nodes subscribe to a topic to receive messages. Let's create a subscriber node that subscribes to the topic called <code>topic</code>. Create a new file called <code>subscriber.py</code> or <code>subscriber.cpp</code> in the <code>py_pubsub</code> or <code>cpp_pubsub</code> package respectively.</p> PythonC++ Bash<pre><code>cd ~/ros2_ws/src/py_pubsub/py_pubsub\ntouch subscriber.py\n</code></pre> Bash<pre><code>cd ~/ros2_ws/src/cpp_pubsub/src\ntouch subscriber.cpp\n</code></pre> <p>This is where we will write our subscriber code. Open the file in your favorite editor and add the following imports:</p> PythonC++ Python<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\n\nclass Subscriber(Node):\n    def __init__(self):\n        ...\n\n    def callback(self, msg):\n        ...\n\n\ndef main(args=None):\n    ...\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> C++<pre><code>#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n\nusing namespace std::chrono_literals;\n\n\nclass Subscriber : public rclcpp::Node\n{\npublic:\n    Subscriber() : Node(\"subscriber\")\n    {\n        ...\n    }\n\nprivate:\n    void callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        ...\n    }\n\n    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;\n};\n\n\nint main(int argc, char **argv)\n{\n    ...\n}\n</code></pre> <p>Now try to create a subscriber node by inheriting from the <code>Node</code> class. Feel free to come back and check the solution if you get stuck.</p> Source Code PythonC++ Python<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Subscriber(Node):\n    def __init__(self):\n        super().__init__(\"subscriber\")\n        self.subscription_ = self.create_subscription(String, \"topic\", self.callback, 10)\n        self.get_logger().info(\"Subscriber has been started\")\n\n    def callback(self, msg):\n        self.get_logger().info(f\"Message received: {msg.data}\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    subscriber = Subscriber()\n    rclpy.spin(subscriber)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Here is the breakdown of the code:</p> Python<pre><code>class Subscriber(Node):\n    def __init__(self):\n        super().__init__(\"subscriber\")\n        self.subscription_ = self.create_subscription(String, \"topic\", self.callback, 10)\n        self.get_logger().info(\"Subscriber has been started\")\n</code></pre> <ul> <li><code>class Subscriber(Node)</code>: This line creates a class called <code>Subscriber</code> that inherits from the <code>Node</code> class.</li> <li><code>super().__init__(\"subscriber\")</code>: This line calls the constructor of the <code>Node</code> class and passes the name of the node as an argument.</li> <li><code>self.subscription_ = self.create_subscription(String, \"topic\", self.callback, 10)</code>: This line creates a subscriber that subscribes to the topic called <code>topic</code> and calls the <code>callback</code> function when a message is received. The queue size is set to 10, this means that if the messages are published faster than they are being processed, the queue will store up to 10 messages before it starts to discard old ones.</li> </ul> Python<pre><code>def callback(self, msg):\n    self.get_logger().info(f\"Message received: {msg.data}\")\n</code></pre> <ul> <li><code>self.get_logger().info(f\"Message received: {msg.data}\")</code>: This line prints the message data to the terminal.</li> </ul> Python<pre><code>def main(args=None):\n    rclpy.init(args=args)\n    subscriber = Subscriber()\n    rclpy.spin(subscriber)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li><code>rclpy.init(args=args)</code>: This line initializes the ROS 2 client library.</li> <li><code>subscriber = Subscriber()</code>: This line creates an instance of the <code>Subscriber</code> class.</li> <li><code>rclpy.spin(subscriber)</code>: This line starts the node. It will keep the node running until it is shutdown.</li> <li><code>rclpy.shutdown()</code>: This line shuts down the ROS 2 client library.</li> </ul> C++<pre><code>#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass Subscriber : public rclcpp::Node\n{\npublic:\n    Subscriber() : Node(\"subscriber\")\n    {\n        subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(\"topic\", 10, std::bind(&amp;Subscriber::callback, this, std::placeholders::_1));\n        RCLCPP_INFO(this-&gt;get_logger(), \"Subscriber has been started\");\n    }\n\nprivate:\n    void callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        RCLCPP_INFO(this-&gt;get_logger(), (\"Message received: \" + msg-&gt;data).c_str());\n    }\n\n    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto subscriber = std::make_shared&lt;Subscriber&gt;();\n    rclcpp::spin(subscriber);\n    rclcpp::shutdown();\n    return 0;\n}\n</code></pre> <p>Here is the breakdown of the code:</p> C++<pre><code>class Subscriber : public rclcpp::Node\n{\npublic:\n    Subscriber() : Node(\"subscriber\")\n    {\n        subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(\"topic\", 10, std::bind(&amp;Subscriber::callback, this, std::placeholders::_1));\n        RCLCPP_INFO(this-&gt;get_logger(), \"Subscriber has been started\");\n    }\n</code></pre> <ul> <li><code>class Subscriber : public rclcpp::Node</code>: This line creates a class called <code>Subscriber</code> that inherits from the <code>Node</code> class.</li> <li><code>Subscriber() : Node(\"subscriber\")</code>: This line calls the constructor of the <code>Node</code> class and passes the name of the node as an argument.</li> <li><code>subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(\"topic\", 10, std::bind(&amp;Subscriber::callback, this, std::placeholders::_1))</code>: This line creates a subscriber that subscribes to the topic called <code>topic</code> and calls the <code>callback</code> function when a message is received. The queue size is set to 10, this means that if the messages are published faster than they are being processed, the queue will store up to 10 messages before it starts to discard old ones.</li> </ul> C++<pre><code>void callback(const std_msgs::msg::String::SharedPtr msg)\n{\n    RCLCPP_INFO(this-&gt;get_logger(), (\"Message received: \" + msg-&gt;data).c_str());\n}\n</code></pre> <ul> <li><code>RCLCPP_INFO(this-&gt;get_logger(), (\"Message received: \" + msg-&gt;data).c_str())</code>: This line prints the message data to the terminal.</li> </ul> C++<pre><code>int main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto subscriber = std::make_shared&lt;Subscriber&gt;();\n    rclcpp::spin(subscriber);\n    rclcpp::shutdown();\n    return 0;\n}\n</code></pre> <ul> <li><code>rclcpp::init(argc, argv)</code>: This line initializes the ROS 2 client library.</li> <li><code>auto subscriber = std::make_shared&lt;Subscriber&gt;()</code>: This line creates an instance of the <code>Subscriber</code> class.</li> <li><code>rclcpp::spin(subscriber)</code>: This line starts the node. It will keep the node running until it is shutdown.</li> <li><code>rclcpp::shutdown()</code>: This line shuts down the ROS 2 client library.</li> </ul>"},{"location":"pub_sub/#adding-dependencies-and-installing-the-package_1","title":"Adding Dependencies and Installing the Package","text":"<p>Since we have already added the dependencies in the previous section, we can skip this step.</p> <p>Now we need to make this script executable.</p> PythonC++ <p>In python to allow the script to be executable, we need to edit <code>setup.py</code> file and add the following line:</p> Python<pre><code>entry_points={\n    \"console_scripts\": [\n        \"publisher = py_pubsub.publisher:main\",\n        \"subscriber = py_pubsub.subscriber:main\"\n    ],\n},\n</code></pre> <p>This will create a script called <code>subscriber</code> that will run the <code>main</code> function in the <code>subscriber.py</code> file.</p> <p>In C++ to allow the script to be executable, we need to edit <code>CMakeLists.txt</code> file and add the following lines:</p> CMake<pre><code>find_package(rclcpp REQUIRED)  # To use the rclcpp library\nfind_package(std_msgs REQUIRED)  # To use the String message type\n\nadd_executable(publisher src/publisher.cpp)\nament_target_dependencies(publisher rclcpp std_msgs)\n\nadd_executable(subscriber src/subscriber.cpp)\nament_target_dependencies(subscriber rclcpp std_msgs)\ninstall(TARGETS publisher subscriber DESTINATION lib/${PROJECT_NAME})\n</code></pre> <p>This will create an executable called <code>subscriber</code> that will run the <code>main</code> function in the <code>subscriber.cpp</code> file.</p> <p>Now we need to build and install the package, to verify that everything is working as expected. Run the following commands:</p> Bash<pre><code>cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n</code></pre> <p>Now run the following command to run the subscriber:</p> PythonC++ Bash<pre><code>ros2 run py_pubsub subscriber\n</code></pre> Bash<pre><code>ros2 run cpp_pubsub subscriber\n</code></pre> <p></p>"},{"location":"pub_sub/#running-the-publisher-and-subscriber","title":"Running the Publisher and Subscriber","text":"<p>Now that we have created the publisher and subscriber, let's run them together. Open two terminals and run the following commands:</p> PythonC++ Bash<pre><code>ros2 run py_pubsub publisher\n</code></pre> Bash<pre><code>ros2 run py_pubsub subscriber\n</code></pre> <p></p> Bash<pre><code>ros2 run cpp_pubsub publisher\n</code></pre> Bash<pre><code>ros2 run cpp_pubsub subscriber\n</code></pre> <p></p>"},{"location":"pub_sub/#summary","title":"Summary","text":"<p>Congratulations! You have successfully created a publisher and subscriber in <code>python</code> and <code>C++</code>. You can find the source code for this tutorial here.</p>"}]}